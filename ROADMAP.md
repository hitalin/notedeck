# NoteDeck Roadmap

## ポジショニング

NoteDeck は Misskey Web UI の **代替** ではなく **補完** である。

ターゲットは「複数サーバーのタイムラインを常時監視するパワーユーザー」。
この層の **日常操作の 80% をデスクトップ内で完結** させ、Web UI を開く頻度を最小化することがゴール。

## 設計原則

- Apple 式直感 UI: 設定項目を増やさず、触ればわかる操作で完結
- 機能網羅より体験品質: 少ない機能を心地よく使えることを優先
- Web UI へのリンク導線: 非対応機能はブラウザで開けるようにする

---

## 構造的に対応しない領域

低頻度・管理系の操作は Web UI の責務とし、実装しない。

| 領域 | 理由 |
|---|---|
| 管理画面 | サーバー管理は Web UI 固有の責務 |
| プロフィール編集 | 年に数回の操作。Web UI リンクで十分 |
| ドライブ管理 | ファイル整理は Web UI の仕事。投稿時アップロードのみ対応 |
| ページ / Play | コンテンツ作成ツール。実装コストに見合わない |
| ウィジェット | Web UI のダッシュボード機能。デッキ UI と設計思想が異なる |
| フォロー管理画面 | 一覧表示・整理は Web UI で。フォロー操作のみ対応 |
| 設定画面の網羅 | Misskey 本家の膨大な設定項目は Apple 式の思想と矛盾 |

**判断基準**: 月 1 回以下の操作 / 作成・管理系 / Web UI リンクで代替可能

---

## Phase 1: 生存条件 — Web UI に戻らせない（カラム種別の拡充）

日常ループ（閲覧・反応・会話）を途切れさせない機能を揃える。
これが欠けると「結局 Web UI でいいや」になる。

- [x] タイムライン（HTL / LTL / STL / GTL / カスタム）
- [x] 通知カラム（リアルタイム）
- [x] 検索カラム
- [x] 投稿（テキスト・CW・公開範囲・ファイル添付・投票・編集）
- [x] リアクション / リプライ / リノート / 引用
- [x] フォロー / アンフォロー
- [x] リストカラム
- [x] アンテナカラム
- [x] ダイレクト投稿カラム（visibility: specified）
- [x] チャットカラム（Misskey v2025.2.0+ chat API、リアルタイム WS 対応）
- [x] クリップカラム
- [x] ユーザーノート一覧カラム
- [x] メンションカラム
- [x] チャンネルカラム
- [x] お気に入りカラム

**Phase 1 完了** — 全 12 種類のカラムが揃い、日常操作のカバー率は目標に到達。

---

## Phase 2: 唯一無二の価値 — デスクトップアプリだからこそ

Phase 1 で蓄積されたローカルキャッシュの上に、Web UI では原理的に不可能な機能を載せる。

- [ ] **横断検索** — 複数サーバー × 全カラムのノートを SQLite FTS で横断検索。
  サーバー A のリスト + サーバー B のアンテナ + サーバー C の HTL をまたいだ検索は NoteDeck だけの体験
- [ ] **未読管理 / マーカー** — 常駐アプリならではの「どこまで読んだか」追跡。
  ブラウザタブでは閉じたら消えるが、デスクトップアプリは状態を保持できる

**前提条件クリア**: Phase 1 で全カラム種別が揃い、複数サーバー × 多様なカラムからノートが
SQLite に蓄積される基盤が完成。横断検索の対象データが十分に蓄積される状態になった。

---

## Phase 3: Hackable — VSCode の世界観を Misskey に

NoteDeck を拡張可能にする 3 本柱。VSCode がエディタの世界で実現したモデルを、
Misskey エコシステムの言語（AiScript）とプロトコルで再構築する。

**3 つの柱が同じコマンドシステムに収斂する:**
- **人間** → コマンドパレットから実行
- **AI** → HTTP API から実行
- **AiScript プラグイン** → コマンドを登録・実行

### 柱 1: コマンドパレット（人間のインターフェース）

VSCode の Ctrl+Shift+P に相当。全操作がコマンドとして登録され、検索・実行できる。

- [x] コマンドパレット基盤（Ctrl+K で起動、fuzzy 検索）
- [x] ショートカットキー連携（コマンドにキーバインドを紐づけ）
- [ ] **キーバインドカスタマイズ** — 設定ファイルでショートカットの自由なリマップ。
  VSCode の `keybindings.json` と同じ思想

### 柱 2: HTTP API（AI・外部ツールのインターフェース）

VSCode の Extension API + Language Server に相当。
Claude Code や AI エージェントが NoteDeck を操作できる外部 API。

- [x] HTTP サーバー基盤（localhost で起動）
- [x] **Bearer トークン認証** — 起動時にランダムトークンを生成しファイルに書き出し。
  Jupyter Notebook 方式で同一マシンの認可済みプロセスのみアクセス可能
- [x] **コマンド実行 API** — 登録済みコマンドを HTTP 経由で実行。
  コマンドパレットで人間ができることは全て API からもできる
- [x] **状態取得 API** — カラム一覧、アクティブカラム、ノート取得等の読み取り操作
- [x] **イベントストリーム** — SSE で状態変化を購読。
  AI が「新着通知があったら要約して」等のリアクティブ処理を実現

### 柱 3: AiScript プラグイン（Misskey ネイティブの拡張言語）

VSCode の TypeScript Extensions に相当するが、言語は **AiScript**。
Misskey ユーザーが既に馴染んでいるサンドボックス言語で、安全に拡張機能を書ける。

- [ ] **AiScript ランタイム** — @syuilo/aiscript の JS 実装を WebView 内で実行。
  Misskey Plugin API (`Plugin:*`, `Mk:*`) の互換レイヤーを提供
- [ ] **NoteDeck 拡張 API** — Misskey 本家にない NoteDeck 固有の拡張ポイント:
  - `Nd:registerCommand` — コマンドパレットにカスタムコマンドを登録
  - `Nd:registerNoteAction` — ノートメニューにカスタムアクションを追加
  - `Nd:registerPostInterruptor` — 投稿前にノート内容を変換
  - `Nd:registerColumnType` — カスタムカラムタイプの定義
  - `Nd:columns` — カラムの追加・削除・並べ替え操作
- [ ] **プラグイン管理 UI** — インストール済みプラグインの有効/無効切替。
  Misskey 本家と同じくテキストベースでコピペ共有・インストール可能

**なぜ AiScript か:**
- **安全** — サンドボックス実行。ファイルシステム・ネットワークへの直接アクセスなし
- **既存文化** — Misskey ユーザーは Plugin / Play で AiScript に馴染んでいる
- **互換性** — Misskey 本家のプラグインを（API 互換の範囲で）そのまま動かせる可能性
- **配布が容易** — テキストベースでコピペ共有可能。Misskey 本家と同じインストール体験

---

## Phase 4: notecli — ヘッドレス Misskey クライアントの分離

NoteDeck の Rust バックエンドから Tauri 非依存のコードを **notecli** として別プロジェクトに切り出す。
CLI / デーモンモードで動作し、GUI 環境なしで AI エージェント（Claude Code, OpenClaw 等）から
Misskey を操作できるようにする。

**notecli は NoteDeck 固有ではなく、汎用 Misskey CLI ツール。**
NoteDeck は notecli をライブラリとして利用する形になる。

### 抽出対象（Tauri 非依存・そのまま移動）

| ファイル | 役割 |
|---------|------|
| api.rs | Misskey HTTP クライアント |
| db.rs | SQLite データ保存 |
| models.rs | Misskey データモデル |
| error.rs | エラー型 |
| keychain.rs | OS 資格情報ストレージ |
| event_bus.rs | イベントバス（tokio broadcast） |

### リファクタリング必要（Tauri 依存の抽象化）

| ファイル | 現状の Tauri 依存 | 対応方針 |
|---------|------------------|---------|
| streaming.rs | `AppHandle.emit()` でフロントエンドにイベント発火 | trait ベースのイベントエミッター |
| http_server.rs | `AppHandle.state::<T>()` で状態取得 | `Arc<T>` を直接保持 |

### NoteDeck に残るもの（Tauri 固有）

- `lib.rs` — Tauri 初期化・プラグイン・システムトレイ
- `commands.rs` — `#[tauri::command]` IPC ハンドラ
- `query_bridge.rs` — Tauri イベントブリッジ

---

## 将来の検討材料

優先度は低いが、技術的に興味深い方向性。

| 項目 | メモ |
|---|---|
| AiScript エディタ / Play 実行 | Phase 3 の AiScript ランタイム上に構築。Monaco/CodeMirror + 本家パーサーで構文チェック・補完・実行プレビューを提供 |
| iOS 対応 | Apple Developer Program ($99/年) + Mac ビルド環境が障壁 |
